{"version":3,"sources":["../src/index.ts","../src/client.ts","../src/encryption.ts","../src/decrypt.ts"],"sourcesContent":["// Core exports\r\nexport { createFhevmInstance, FhevmClientImpl } from './client';\r\nexport { encryptInput, EncryptionHelper } from './encryption';\r\nexport { userDecrypt, publicDecrypt } from './decrypt';\r\n\r\n// Type exports\r\nexport type {\r\n  EthersProvider,\r\n  EncryptionType,\r\n  EncryptedValue,\r\n  FhevmConfig,\r\n  FhevmClient,\r\n  DecryptOptions,\r\n  PublicDecryptOptions,\r\n} from './types';\r\n","import { Contract } from 'ethers';\r\nimport { createInstance } from 'fhevmjs';\r\nimport type { FhevmInstance } from 'fhevmjs';\r\nimport type { FhevmConfig, FhevmClient, EthersProvider } from './types';\r\n\r\nexport class FhevmClientImpl implements FhevmClient {\r\n  private instance: FhevmInstance | null = null;\r\n  private provider: EthersProvider;\r\n  private config: FhevmConfig;\r\n\r\n  constructor(config: FhevmConfig) {\r\n    this.provider = config.provider;\r\n    this.config = config;\r\n  }\r\n\r\n  async initialize(): Promise<void> {\r\n    if (this.instance) return;\r\n\r\n    const chainId = this.config.chainId ?? (await this.provider.getNetwork()).chainId;\r\n\r\n    this.instance = await createInstance({\r\n      chainId: Number(chainId),\r\n      networkUrl: this.config.gatewayUrl,\r\n      aclAddress: this.config.aclAddress,\r\n    });\r\n  }\r\n\r\n  getInstance(): FhevmInstance {\r\n    if (!this.instance) {\r\n      throw new Error('FHEVM instance not initialized. Call initialize() first.');\r\n    }\r\n    return this.instance;\r\n  }\r\n\r\n  async getSigner() {\r\n    const signer = await this.provider.getSigner();\r\n    return signer;\r\n  }\r\n\r\n  getContract(address: string, abi: any): Contract {\r\n    return new Contract(address, abi, this.provider);\r\n  }\r\n\r\n  async getConnectedContract(address: string, abi: any): Promise<Contract> {\r\n    const signer = await this.getSigner();\r\n    return new Contract(address, abi, signer);\r\n  }\r\n}\r\n\r\nexport async function createFhevmInstance(config: FhevmConfig): Promise<FhevmClient> {\r\n  const client = new FhevmClientImpl(config);\r\n  await client.initialize();\r\n  return client;\r\n}\r\n","import type { FhevmInstance } from 'fhevmjs';\r\nimport type { EncryptionType, EncryptedValue } from './types';\r\n\r\nexport async function encryptInput(\r\n  instance: FhevmInstance,\r\n  value: number | boolean | string | bigint,\r\n  type: EncryptionType\r\n): Promise<EncryptedValue> {\r\n  let encryptedData: Uint8Array;\r\n  const handles: string[] = [];\r\n\r\n  switch (type) {\r\n    case 'bool':\r\n      encryptedData = await (instance as any).encrypt_bool(Boolean(value));\r\n      break;\r\n    case 'uint8':\r\n      encryptedData = await (instance as any).encrypt_uint8(Number(value));\r\n      break;\r\n    case 'uint16':\r\n      encryptedData = await (instance as any).encrypt_uint16(Number(value));\r\n      break;\r\n    case 'uint32':\r\n      encryptedData = await (instance as any).encrypt_uint32(Number(value));\r\n      break;\r\n    case 'uint64':\r\n      encryptedData = await (instance as any).encrypt_uint64(BigInt(value));\r\n      break;\r\n    case 'uint128':\r\n      encryptedData = await (instance as any).encrypt_uint128(BigInt(value));\r\n      break;\r\n    case 'uint256':\r\n      encryptedData = await (instance as any).encrypt_uint256(BigInt(value));\r\n      break;\r\n    case 'address':\r\n      encryptedData = await (instance as any).encrypt_address(String(value));\r\n      break;\r\n    default:\r\n      throw new Error(`Unsupported encryption type: ${type}`);\r\n  }\r\n\r\n  return {\r\n    data: encryptedData,\r\n    handles,\r\n  };\r\n}\r\n\r\nexport class EncryptionHelper {\r\n  constructor(private instance: FhevmInstance) {}\r\n\r\n  async encrypt(value: number | boolean | string | bigint, type: EncryptionType): Promise<EncryptedValue> {\r\n    return encryptInput(this.instance, value, type);\r\n  }\r\n\r\n  async encryptBool(value: boolean): Promise<EncryptedValue> {\r\n    return this.encrypt(value, 'bool');\r\n  }\r\n\r\n  async encryptUint8(value: number): Promise<EncryptedValue> {\r\n    return this.encrypt(value, 'uint8');\r\n  }\r\n\r\n  async encryptUint16(value: number): Promise<EncryptedValue> {\r\n    return this.encrypt(value, 'uint16');\r\n  }\r\n\r\n  async encryptUint32(value: number): Promise<EncryptedValue> {\r\n    return this.encrypt(value, 'uint32');\r\n  }\r\n\r\n  async encryptUint64(value: bigint | number): Promise<EncryptedValue> {\r\n    return this.encrypt(value, 'uint64');\r\n  }\r\n\r\n  async encryptUint128(value: bigint | number): Promise<EncryptedValue> {\r\n    return this.encrypt(value, 'uint128');\r\n  }\r\n\r\n  async encryptUint256(value: bigint | number | string): Promise<EncryptedValue> {\r\n    return this.encrypt(value, 'uint256');\r\n  }\r\n\r\n  async encryptAddress(value: string): Promise<EncryptedValue> {\r\n    return this.encrypt(value, 'address');\r\n  }\r\n}\r\n","import type { Signer } from 'ethers';\r\nimport type { DecryptOptions, PublicDecryptOptions } from './types';\r\n\r\n/**\r\n * Decrypt encrypted data using user's EIP-712 signature\r\n * This allows the user to decrypt their own encrypted data\r\n */\r\nexport async function userDecrypt(options: DecryptOptions): Promise<bigint> {\r\n  const { contractAddress, handle, signer } = options;\r\n\r\n  // In a real implementation, this would:\r\n  // 1. Request EIP-712 signature from the user\r\n  // 2. Submit the signature to the gateway\r\n  // 3. Retrieve the decrypted value\r\n\r\n  // Placeholder implementation\r\n  const provider = signer.provider;\r\n  const network = provider ? await provider.getNetwork() : { chainId: 31337n };\r\n\r\n  const domain = {\r\n    name: 'FHEVM',\r\n    version: '1',\r\n    chainId: Number(network.chainId),\r\n    verifyingContract: contractAddress,\r\n  };\r\n\r\n  const types = {\r\n    Reencrypt: [\r\n      { name: 'handle', type: 'bytes32' },\r\n    ],\r\n  };\r\n\r\n  const value = {\r\n    handle,\r\n  };\r\n\r\n  try {\r\n    // Sign the EIP-712 message\r\n    await signer.signTypedData(domain, types, value);\r\n\r\n    // In production, submit to gateway and return decrypted value\r\n    // For now, return placeholder\r\n    return BigInt(0);\r\n  } catch (error) {\r\n    throw new Error(`Failed to decrypt: ${error}`);\r\n  }\r\n}\r\n\r\n/**\r\n * Decrypt publicly available encrypted data\r\n * This is for data that has been explicitly made public\r\n */\r\nexport async function publicDecrypt(options: PublicDecryptOptions): Promise<bigint> {\r\n  const { contractAddress, handle } = options;\r\n\r\n  // In a real implementation, this would:\r\n  // 1. Query the public decryption gateway\r\n  // 2. Retrieve the decrypted value without signature\r\n\r\n  // Placeholder implementation\r\n  console.log(`Public decrypt for contract ${contractAddress}, handle ${handle}`);\r\n  return BigInt(0);\r\n}\r\n"],"mappings":"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","names":[]}