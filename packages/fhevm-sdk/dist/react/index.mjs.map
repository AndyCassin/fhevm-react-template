{"version":3,"sources":["../../src/react/FhevmProvider.tsx","../../src/client.ts","../../src/react/useFhevmClient.ts","../../src/react/useFhevmContract.ts","../../src/react/useEncryptedInput.ts","../../src/encryption.ts","../../src/react/useDecrypt.ts","../../src/decrypt.ts"],"sourcesContent":["import React, { createContext, useContext, useEffect, useState, ReactNode } from 'react';\r\nimport { createFhevmInstance } from '../client';\r\nimport type { FhevmClient, EthersProvider } from '../types';\r\n\r\ninterface FhevmContextValue {\r\n  client: FhevmClient | null;\r\n  isLoading: boolean;\r\n  isReady: boolean;\r\n  error: Error | null;\r\n}\r\n\r\nconst FhevmContext = createContext<FhevmContextValue | undefined>(undefined);\r\n\r\nexport interface FhevmProviderProps {\r\n  provider: EthersProvider;\r\n  chainId?: number;\r\n  gatewayUrl?: string;\r\n  aclAddress?: string;\r\n  children: ReactNode;\r\n}\r\n\r\nexport function FhevmProvider({\r\n  provider,\r\n  chainId,\r\n  gatewayUrl,\r\n  aclAddress,\r\n  children,\r\n}: FhevmProviderProps) {\r\n  const [client, setClient] = useState<FhevmClient | null>(null);\r\n  const [isLoading, setIsLoading] = useState(true);\r\n  const [error, setError] = useState<Error | null>(null);\r\n\r\n  useEffect(() => {\r\n    let mounted = true;\r\n\r\n    async function initFhevm() {\r\n      try {\r\n        setIsLoading(true);\r\n        setError(null);\r\n\r\n        const fhevmClient = await createFhevmInstance({\r\n          provider,\r\n          chainId,\r\n          gatewayUrl,\r\n          aclAddress,\r\n        });\r\n\r\n        if (mounted) {\r\n          setClient(fhevmClient);\r\n          setIsLoading(false);\r\n        }\r\n      } catch (err) {\r\n        if (mounted) {\r\n          setError(err as Error);\r\n          setIsLoading(false);\r\n        }\r\n      }\r\n    }\r\n\r\n    initFhevm();\r\n\r\n    return () => {\r\n      mounted = false;\r\n    };\r\n  }, [provider, chainId, gatewayUrl, aclAddress]);\r\n\r\n  const value: FhevmContextValue = {\r\n    client,\r\n    isLoading,\r\n    isReady: !!client && !isLoading,\r\n    error,\r\n  };\r\n\r\n  return <FhevmContext.Provider value={value}>{children}</FhevmContext.Provider>;\r\n}\r\n\r\nexport function useFhevmContext(): FhevmContextValue {\r\n  const context = useContext(FhevmContext);\r\n  if (context === undefined) {\r\n    throw new Error('useFhevmContext must be used within a FhevmProvider');\r\n  }\r\n  return context;\r\n}\r\n","import { Contract } from 'ethers';\r\nimport { createInstance } from 'fhevmjs';\r\nimport type { FhevmInstance } from 'fhevmjs';\r\nimport type { FhevmConfig, FhevmClient, EthersProvider } from './types';\r\n\r\nexport class FhevmClientImpl implements FhevmClient {\r\n  private instance: FhevmInstance | null = null;\r\n  private provider: EthersProvider;\r\n  private config: FhevmConfig;\r\n\r\n  constructor(config: FhevmConfig) {\r\n    this.provider = config.provider;\r\n    this.config = config;\r\n  }\r\n\r\n  async initialize(): Promise<void> {\r\n    if (this.instance) return;\r\n\r\n    const chainId = this.config.chainId ?? (await this.provider.getNetwork()).chainId;\r\n\r\n    this.instance = await createInstance({\r\n      chainId: Number(chainId),\r\n      networkUrl: this.config.gatewayUrl,\r\n      aclAddress: this.config.aclAddress,\r\n    });\r\n  }\r\n\r\n  getInstance(): FhevmInstance {\r\n    if (!this.instance) {\r\n      throw new Error('FHEVM instance not initialized. Call initialize() first.');\r\n    }\r\n    return this.instance;\r\n  }\r\n\r\n  async getSigner() {\r\n    const signer = await this.provider.getSigner();\r\n    return signer;\r\n  }\r\n\r\n  getContract(address: string, abi: any): Contract {\r\n    return new Contract(address, abi, this.provider);\r\n  }\r\n\r\n  async getConnectedContract(address: string, abi: any): Promise<Contract> {\r\n    const signer = await this.getSigner();\r\n    return new Contract(address, abi, signer);\r\n  }\r\n}\r\n\r\nexport async function createFhevmInstance(config: FhevmConfig): Promise<FhevmClient> {\r\n  const client = new FhevmClientImpl(config);\r\n  await client.initialize();\r\n  return client;\r\n}\r\n","import { useState, useEffect } from 'react';\r\nimport { createFhevmInstance } from '../client';\r\nimport type { FhevmClient, EthersProvider } from '../types';\r\n\r\nexport interface UseFhevmClientOptions {\r\n  provider?: EthersProvider;\r\n  chainId?: number;\r\n  gatewayUrl?: string;\r\n  aclAddress?: string;\r\n}\r\n\r\nexport interface UseFhevmClientResult {\r\n  client: FhevmClient | null;\r\n  isLoading: boolean;\r\n  isReady: boolean;\r\n  error: Error | null;\r\n}\r\n\r\nexport function useFhevmClient(options: UseFhevmClientOptions = {}): UseFhevmClientResult {\r\n  const [client, setClient] = useState<FhevmClient | null>(null);\r\n  const [isLoading, setIsLoading] = useState(true);\r\n  const [error, setError] = useState<Error | null>(null);\r\n\r\n  const { provider, chainId, gatewayUrl, aclAddress } = options;\r\n\r\n  useEffect(() => {\r\n    if (!provider) {\r\n      setIsLoading(false);\r\n      return;\r\n    }\r\n\r\n    let mounted = true;\r\n\r\n    async function initClient() {\r\n      try {\r\n        setIsLoading(true);\r\n        setError(null);\r\n\r\n        const fhevmClient = await createFhevmInstance({\r\n          provider: provider!,\r\n          chainId,\r\n          gatewayUrl,\r\n          aclAddress,\r\n        });\r\n\r\n        if (mounted) {\r\n          setClient(fhevmClient);\r\n          setIsLoading(false);\r\n        }\r\n      } catch (err) {\r\n        if (mounted) {\r\n          setError(err as Error);\r\n          setIsLoading(false);\r\n        }\r\n      }\r\n    }\r\n\r\n    initClient();\r\n\r\n    return () => {\r\n      mounted = false;\r\n    };\r\n  }, [provider, chainId, gatewayUrl, aclAddress]);\r\n\r\n  return {\r\n    client,\r\n    isLoading,\r\n    isReady: !!client && !isLoading,\r\n    error,\r\n  };\r\n}\r\n","import { useMemo, useEffect, useState } from 'react';\r\nimport { Contract } from 'ethers';\r\nimport { useFhevmContext } from './FhevmProvider';\r\n\r\nexport interface UseFhevmContractOptions {\r\n  address: string;\r\n  abi: any;\r\n  withSigner?: boolean;\r\n}\r\n\r\nexport function useFhevmContract(options: UseFhevmContractOptions): Contract | null {\r\n  const { address, abi, withSigner = false } = options;\r\n  const { client, isReady } = useFhevmContext();\r\n  const [contract, setContract] = useState<Contract | null>(null);\r\n\r\n  useEffect(() => {\r\n    if (!isReady || !client) {\r\n      setContract(null);\r\n      return;\r\n    }\r\n\r\n    async function createContract() {\r\n      if (!client) return;\r\n\r\n      try {\r\n        if (withSigner) {\r\n          const connectedContract = await client.getConnectedContract(address, abi);\r\n          setContract(connectedContract);\r\n        } else {\r\n          const readOnlyContract = client.getContract(address, abi);\r\n          setContract(readOnlyContract);\r\n        }\r\n      } catch (error) {\r\n        console.error('Error creating contract:', error);\r\n        setContract(null);\r\n      }\r\n    }\r\n\r\n    createContract();\r\n  }, [address, abi, withSigner, client, isReady]);\r\n\r\n  return contract;\r\n}\r\n","import { useState, useCallback } from 'react';\r\nimport { useFhevmContext } from './FhevmProvider';\r\nimport { encryptInput } from '../encryption';\r\nimport type { EncryptionType, EncryptedValue } from '../types';\r\n\r\nexport interface UseEncryptedInputResult {\r\n  encrypt: (value: number | boolean | string | bigint, type: EncryptionType) => Promise<EncryptedValue>;\r\n  isEncrypting: boolean;\r\n  error: Error | null;\r\n}\r\n\r\nexport function useEncryptedInput(): UseEncryptedInputResult {\r\n  const { client, isReady } = useFhevmContext();\r\n  const [isEncrypting, setIsEncrypting] = useState(false);\r\n  const [error, setError] = useState<Error | null>(null);\r\n\r\n  const encrypt = useCallback(\r\n    async (value: number | boolean | string | bigint, type: EncryptionType): Promise<EncryptedValue> => {\r\n      if (!isReady || !client) {\r\n        throw new Error('FHEVM client not ready');\r\n      }\r\n\r\n      try {\r\n        setIsEncrypting(true);\r\n        setError(null);\r\n\r\n        const instance = client.getInstance();\r\n        const encrypted = await encryptInput(instance, value, type);\r\n\r\n        setIsEncrypting(false);\r\n        return encrypted;\r\n      } catch (err) {\r\n        const error = err as Error;\r\n        setError(error);\r\n        setIsEncrypting(false);\r\n        throw error;\r\n      }\r\n    },\r\n    [client, isReady]\r\n  );\r\n\r\n  return {\r\n    encrypt,\r\n    isEncrypting,\r\n    error,\r\n  };\r\n}\r\n","import type { FhevmInstance } from 'fhevmjs';\r\nimport type { EncryptionType, EncryptedValue } from './types';\r\n\r\nexport async function encryptInput(\r\n  instance: FhevmInstance,\r\n  value: number | boolean | string | bigint,\r\n  type: EncryptionType\r\n): Promise<EncryptedValue> {\r\n  let encryptedData: Uint8Array;\r\n  const handles: string[] = [];\r\n\r\n  switch (type) {\r\n    case 'bool':\r\n      encryptedData = await (instance as any).encrypt_bool(Boolean(value));\r\n      break;\r\n    case 'uint8':\r\n      encryptedData = await (instance as any).encrypt_uint8(Number(value));\r\n      break;\r\n    case 'uint16':\r\n      encryptedData = await (instance as any).encrypt_uint16(Number(value));\r\n      break;\r\n    case 'uint32':\r\n      encryptedData = await (instance as any).encrypt_uint32(Number(value));\r\n      break;\r\n    case 'uint64':\r\n      encryptedData = await (instance as any).encrypt_uint64(BigInt(value));\r\n      break;\r\n    case 'uint128':\r\n      encryptedData = await (instance as any).encrypt_uint128(BigInt(value));\r\n      break;\r\n    case 'uint256':\r\n      encryptedData = await (instance as any).encrypt_uint256(BigInt(value));\r\n      break;\r\n    case 'address':\r\n      encryptedData = await (instance as any).encrypt_address(String(value));\r\n      break;\r\n    default:\r\n      throw new Error(`Unsupported encryption type: ${type}`);\r\n  }\r\n\r\n  return {\r\n    data: encryptedData,\r\n    handles,\r\n  };\r\n}\r\n\r\nexport class EncryptionHelper {\r\n  constructor(private instance: FhevmInstance) {}\r\n\r\n  async encrypt(value: number | boolean | string | bigint, type: EncryptionType): Promise<EncryptedValue> {\r\n    return encryptInput(this.instance, value, type);\r\n  }\r\n\r\n  async encryptBool(value: boolean): Promise<EncryptedValue> {\r\n    return this.encrypt(value, 'bool');\r\n  }\r\n\r\n  async encryptUint8(value: number): Promise<EncryptedValue> {\r\n    return this.encrypt(value, 'uint8');\r\n  }\r\n\r\n  async encryptUint16(value: number): Promise<EncryptedValue> {\r\n    return this.encrypt(value, 'uint16');\r\n  }\r\n\r\n  async encryptUint32(value: number): Promise<EncryptedValue> {\r\n    return this.encrypt(value, 'uint32');\r\n  }\r\n\r\n  async encryptUint64(value: bigint | number): Promise<EncryptedValue> {\r\n    return this.encrypt(value, 'uint64');\r\n  }\r\n\r\n  async encryptUint128(value: bigint | number): Promise<EncryptedValue> {\r\n    return this.encrypt(value, 'uint128');\r\n  }\r\n\r\n  async encryptUint256(value: bigint | number | string): Promise<EncryptedValue> {\r\n    return this.encrypt(value, 'uint256');\r\n  }\r\n\r\n  async encryptAddress(value: string): Promise<EncryptedValue> {\r\n    return this.encrypt(value, 'address');\r\n  }\r\n}\r\n","import { useState, useCallback } from 'react';\r\nimport { useFhevmContext } from './FhevmProvider';\r\nimport { userDecrypt } from '../decrypt';\r\n\r\nexport interface UseDecryptResult {\r\n  decrypt: (contractAddress: string, handle: string) => Promise<bigint>;\r\n  isDecrypting: boolean;\r\n  result: bigint | null;\r\n  error: Error | null;\r\n}\r\n\r\nexport function useDecrypt(): UseDecryptResult {\r\n  const { client, isReady } = useFhevmContext();\r\n  const [isDecrypting, setIsDecrypting] = useState(false);\r\n  const [result, setResult] = useState<bigint | null>(null);\r\n  const [error, setError] = useState<Error | null>(null);\r\n\r\n  const decrypt = useCallback(\r\n    async (contractAddress: string, handle: string): Promise<bigint> => {\r\n      if (!isReady || !client) {\r\n        throw new Error('FHEVM client not ready');\r\n      }\r\n\r\n      try {\r\n        setIsDecrypting(true);\r\n        setError(null);\r\n\r\n        const signer = await client.getSigner();\r\n        const decrypted = await userDecrypt({\r\n          contractAddress,\r\n          handle,\r\n          signer,\r\n        });\r\n\r\n        setResult(decrypted);\r\n        setIsDecrypting(false);\r\n        return decrypted;\r\n      } catch (err) {\r\n        const error = err as Error;\r\n        setError(error);\r\n        setIsDecrypting(false);\r\n        throw error;\r\n      }\r\n    },\r\n    [client, isReady]\r\n  );\r\n\r\n  return {\r\n    decrypt,\r\n    isDecrypting,\r\n    result,\r\n    error,\r\n  };\r\n}\r\n","import type { Signer } from 'ethers';\r\nimport type { DecryptOptions, PublicDecryptOptions } from './types';\r\n\r\n/**\r\n * Decrypt encrypted data using user's EIP-712 signature\r\n * This allows the user to decrypt their own encrypted data\r\n */\r\nexport async function userDecrypt(options: DecryptOptions): Promise<bigint> {\r\n  const { contractAddress, handle, signer } = options;\r\n\r\n  // In a real implementation, this would:\r\n  // 1. Request EIP-712 signature from the user\r\n  // 2. Submit the signature to the gateway\r\n  // 3. Retrieve the decrypted value\r\n\r\n  // Placeholder implementation\r\n  const provider = signer.provider;\r\n  const network = provider ? await provider.getNetwork() : { chainId: 31337n };\r\n\r\n  const domain = {\r\n    name: 'FHEVM',\r\n    version: '1',\r\n    chainId: Number(network.chainId),\r\n    verifyingContract: contractAddress,\r\n  };\r\n\r\n  const types = {\r\n    Reencrypt: [\r\n      { name: 'handle', type: 'bytes32' },\r\n    ],\r\n  };\r\n\r\n  const value = {\r\n    handle,\r\n  };\r\n\r\n  try {\r\n    // Sign the EIP-712 message\r\n    await signer.signTypedData(domain, types, value);\r\n\r\n    // In production, submit to gateway and return decrypted value\r\n    // For now, return placeholder\r\n    return BigInt(0);\r\n  } catch (error) {\r\n    throw new Error(`Failed to decrypt: ${error}`);\r\n  }\r\n}\r\n\r\n/**\r\n * Decrypt publicly available encrypted data\r\n * This is for data that has been explicitly made public\r\n */\r\nexport async function publicDecrypt(options: PublicDecryptOptions): Promise<bigint> {\r\n  const { contractAddress, handle } = options;\r\n\r\n  // In a real implementation, this would:\r\n  // 1. Query the public decryption gateway\r\n  // 2. Retrieve the decrypted value without signature\r\n\r\n  // Placeholder implementation\r\n  console.log(`Public decrypt for contract ${contractAddress}, handle ${handle}`);\r\n  return BigInt(0);\r\n}\r\n"],"mappings":"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","names":["useState","useEffect","useState","useEffect","useEffect","useState","useState","useEffect","useState","useState","error","useState","useCallback","useState","useCallback","error"]}